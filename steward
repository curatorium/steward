#!/bin/bash
# Copyright (c) 2025 Mihai Stancu (https://github.com/curatorium)

# @name steward
# @type command
# @desc Declarative DSL for installing packages, in a shareable file format called Stewardfile.
#
# @usage steward [-t|--task <task>] [...file|url] < Stewardfile
# @usage cat Stewardfile | steward [-t|--task <task>] [...file|url]
#
# @opt  [-n|--namespace] -- Namespace (keyword prefix).
# @opt  [-t|--task] -- Run only the specified task (function name) from the Stewardfile.
# @flag [-f|--force] -- Force -- skip all guard checks (treat every guard as passed).
# @flag [-d|--dry-run] -- Dry run -- read the Stewardfiles, check the syntax & parameters, display what commands would be executed.
# @opt  [-x|--trace <lvl: app|all>] -- Level of trace tracing, "app" traces only calls from this file, "all" also traces dependencies. Default none.
# @flag [-h|--help] -- Prints out the usage guide.
#
# @arg [...file|url] -- Paths or URLs to process, default: Stewardfile
function steward:main() {
	local ARGS=("$@");

	local help=;       args:flag help h;
	[[ "$help" == "true" ]] && steward:help && return;

	local trace=;      args:opt  trace x;
	# shellcheck disable=SC2064
	[[ -n "$trace" ]] && "trace:$trace" && trap "trace:stop" EXIT;

	local namespace=;  args:opt  namespace n;
	local task=;       args:opt  task t;
	local force=;      args:flag force f; # dynamic scope: read by steward:guard()
	local dry_run=;    args:flag dry-run d;

	steward:init;

	# When sourced (not executed directly), stop here — only export functions, don't run the pipeline.
	[[ "${BASH_SOURCE[0]}" != "${0}" ]] && return;


	# Detect stdin: drain redirects and pipes to a temp file; timeout prevents hanging on Docker's writerless FIFO.
	stat -L -c '%F' /dev/stdin 2>/dev/null | grep -qE 'regular file|fifo' &&
		timeout 0.2 cat > /tmp/steward/stdin 2>/dev/null &&
		[[ -s /tmp/steward/stdin ]] &&
		ARGS+=("/tmp/steward/stdin");

	# Default file to read is Stewardfile (or .dist fallback)
	[[ ${#ARGS[@]} -eq 0 && -f Stewardfile ]]      && ARGS+=(Stewardfile);
	[[ ${#ARGS[@]} -eq 0 && -f Stewardfile.dist ]]  && ARGS+=(Stewardfile.dist);

	# Outer subshell: isolates aliases and function definitions so they don't leak into the caller's scope.
	(
		# DSL syntactic sugar for Stewardfiles
		namespace:use "steward:*" as "$namespace";
		# Allows `task` to be used instead of function `task foo() { ... }`
		alias task='function';

		local before; before=$(declare -F | awk '{print $3}' | sort);
		for file in "${ARGS[@]}"; do
			# Per-file subshell: isolates each Stewardfile's tasks
			(
				steward:include "$file";

				# Identify functions defined by the Stewardfile
				funcs="$(comm -13 <(printf "%s\n" "$before") <(declare -F | awk '{print $3}' | sort))"
				for func in $funcs; do
				  [[ -n "$task" && "$func" != "$task" ]] && continue;
				  # Per-task subshell: guard's `exit 0` terminates only this subshell, not the whole pipeline
				  ("$func");
				done
			)
		done
	);

	steward:apply "$@";
}

function steward:init() {
	strict:on;

	rm -fR /tmp/steward;
	mkdir -p /tmp/steward;

	# Expose architecture & distro info
	ARCH="$(dpkg --print-architecture)";
	DEBIAN_FRONTEND=noninteractive
	STEWARDFILE="${BASH_SOURCE[0]}";
	STEWARDFILE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)";

	# shellcheck source=/dev/null
	source /etc/os-release;
	export ARCH DEBIAN_FRONTEND STEWARDFILE STEWARDFILE_DIR;

	# Ensure curl & CA certs are available (needed by bin, ext, key, src, deb, include)
	cat <<-'SH' >> /tmp/steward/000--prereqs.sh
		mkdir -p /var/cache/steward;

		# Fresh Docker images or apt clean leave this directory missing or empty — force an update
		# Check for actual package list files, not just any files (auxfiles dir can exist but is not a package list)
		if [[ -z "$(find /var/lib/apt/lists -maxdepth 1 -name '*_Packages' -o -name '*_InRelease' 2>/dev/null)" ]]; then
			apt update -qq;
		fi

		if ! command -V curl >/dev/null 2>&1 || ! command -V gpg >/dev/null 2>&1; then
			apt install -qqy --no-install-recommends apt-transport-https ca-certificates curl gpg;
		fi
	SH
}

# @name include
# @type keyword
# @desc Include another Stewardfile (supports local files, URLs, and GitHub shorthand)
#
# @usage include <file|url>
#
# @arg <file|url> -- Local path, URL
function steward:include() {
	local ARGS=("$@");
	local url="" file=; args:arg url '^https?://' || args:arg file;

	if [[ -n "$url" ]]; then
		file="$(printf '%s' "$url" | sed -E 's#[^A-Za-z0-9._-]+#-#g')";
		file="/var/cache/steward/$file";
		curl -1fsSLR -z "$file" -o "$file" "$url";
	fi

	# shellcheck source=/dev/null
	source "$file";
}

# @name guard
# @type keyword
#
# @desc Skip the current function if a condition is already met (command exists, file exists, or directory exists).
# @desc Must be called inside a Stewardfile function (which runs in a subshell). Uses exit 0 to bail out.
#
# @usage guard <command>
# @usage guard --file <file>
# @usage guard --dir <dir>
#
# @flag [-f|--file] -- Check for file existence instead of command
# @flag [-d|--dir] -- Check for directory existence instead of command
# @arg <name> -- Command name, file path, or directory path to check
function steward:guard() {
	[[ "${force:-}" == "true" ]] && return 0; # dynamic scope: set in steward:main()

	local ARGS=("$@");
	local file=; args:flag file f;
	local dir=;  args:flag dir d;
	local name=; args:arg name;

	# exit (not return): each task runs in its own subshell, exit 0 skips the rest of the task
	if [[ "$file" == "true" ]]; then
		[[ -f "$name" ]] && exit 0;
	elif [[ "$dir" == "true" ]]; then
		[[ -d "$name" ]] && exit 0;
	else
		command -v "$name" >/dev/null 2>&1 && exit 0;
	fi
	return 0;
}

# @name key
# @type keyword
# @desc Add a GPG keyring for package verification
#
# @usage key <name> <url>
#
# @arg <name> -- Keyring filename (without .gpg extension)
# @arg <url> -- URL to the GPG key (ASCII-armored or binary)
function steward:key() {
	local ARGS=("$@");
	local name=; args:arg name || return;
	local url=;  args:arg url '^https?://' || return;


	cat <<-SH >> /tmp/steward/100--key-setup.sh
		curl -1fsSLR -z '/var/cache/steward/$name.asc' -o '/var/cache/steward/$name.asc' '$url';
		if grep -qe '^-----BEGIN PGP PUBLIC KEY BLOCK-----' '/var/cache/steward/$name.asc'; then
			gpg --dearmor < '/var/cache/steward/$name.asc' > '/usr/share/keyrings/$name.gpg';
		else
			cp '/var/cache/steward/$name.asc' '/usr/share/keyrings/$name.gpg';
		fi

		chown root:root '/usr/share/keyrings/$name.gpg';
		chmod u+rw,go+r '/usr/share/keyrings/$name.gpg';
	SH
}

# @name src
# @type keyword
# @desc Add an APT repository source list
#
# @usage src [--no-key] <name> <repo> [dist] [...comp]
# @usage src <url:*.deb>
#
# @flag [--no-key] -- Skip keyring verification
# @arg <name> -- Source list filename (without .list extension)
# @arg <repo> -- APT repository URL (e.g. "https://example.com/repo/")
# @arg [dist] -- Distribution codename (suite) (ex.: jammy, bookwork, $VERSION_CODENAME)
# @arg [...comp] -- Component(s) (ex.: main, security, universe)
function steward:src() {
	local ARGS=("$@");

	local url=;    args:arg -o url '.deb$';
	if [[ -n "$url" ]]; then
		file="$(printf '%s' "$url" | sed -E 's#[^A-Za-z0-9._-]+#-#g')";
		cat <<-SH >> "/tmp/steward/110--src-setup.sh"
			curl -1fsSLR -z '/var/cache/steward/$file' -o '/var/cache/steward/$file' '$url';
			apt install -qqy --no-install-recommends '/var/cache/steward/$file';
		SH
		return;
	fi

	local no_key=; args:flag no-key "";
	local name=;   args:arg name || return;
	local repo=;   args:arg repo;
	local dist=;   args:arg -o dist;
	local comp="${ARGS[*]}";

	local signer=; [[ "$no_key" != "true" ]] && signer="[signed-by=/usr/share/keyrings/$name.gpg]";

	cat <<-SH >> /tmp/steward/110--src-setup.sh
		echo 'deb $signer $repo $dist $comp' > '/etc/apt/sources.list.d/$name.list';
		chown root:root '/etc/apt/sources.list.d/$name.list';
		chmod u+rw,go+r '/etc/apt/sources.list.d/$name.list';
	SH
}

# @name apt
# @type keyword
# @desc Schedule an APT package for installation
#
# @usage apt [--try|--temp] <name[=version]>
#
# @flag [--try] -- Don't fail if package unavailable
# @flag [--temp] -- Temporary package, removed after all installers finish (build deps)
# @arg <name[=version]> -- Package name, optionally with =version suffix
function steward:apt() {
	local ARGS=("$@");
	local try=;  args:flag try "";
	local temp=; args:flag temp "";
	local name=; args:arg name || return;
	local mod=;

	[[ "$try" == "true" ]] && mod="-try";
	[[ "$temp" == "true" ]] && mod="-tmp";
	echo "$name" >> "/tmp/steward/apt-packages$mod";
}

# @name deb
# @type keyword
# @desc Schedule a .deb package for installation
#
# @usage deb [--try|--temp] <url>
#
# @flag [--try] -- Don't fail if package unavailable
# @flag [--temp] -- Temporary package, removed after all installers finish (build deps)
#
# @arg <url> -- URL to a .deb file
function steward:deb() {
	local ARGS=("$@");
	local try=;  args:flag try "";
	local temp=; args:flag temp "";
	local url=;  args:arg url '^https?://' || return;
	local file="$url";
	local mod=;
	local onFail=;

	[[ "$try" == "true" ]] && mod="-try" && onFail="|| true";
	[[ "$temp" == "true" ]] && mod="-tmp";
	file="$(printf '%s' "$url" | sed -E 's#[^A-Za-z0-9._-]+#-#g')";

	cat <<-SH >> "/tmp/steward/120--deb-download.sh"
		curl -1fsSLR -z '/var/cache/apt/archives/$file' -o '/var/cache/apt/archives/$file' '$url' $onFail;
	SH
	echo "/var/cache/apt/archives/$file" >> "/tmp/steward/apt-packages$mod";
}

# @name bin
# @type keyword
# @desc Download and install a binary to /usr/local/bin
#
# @usage bin <name> <url>
#
# @arg <name> -- Binary filename in /usr/local/bin
# @arg <url> -- URL to download the binary from
function steward:bin() {
	local ARGS=("$@");
	local name=; args:arg name || return;
	local url=;  args:arg url '^https?://' || return;

	cat <<-SH >> /tmp/steward/150--bin-install.sh
		curl -1fsSLR -z '/var/cache/steward/$name' -o '/var/cache/steward/$name' '$url';
		cp '/var/cache/steward/$name' '/usr/local/bin/$name';
		chown root:root '/usr/local/bin/$name';
		chmod +x '/usr/local/bin/$name';
	SH
}

# @name ext
# @type keyword
# @desc Execute an external installer script from a URL
#
# @usage ext <url> [shell] [...args]
#
# @arg <url> -- URL to the installer script
# @arg [shell] -- Interpreter to use. Default: bash.
# @arg [...args] -- Additional arguments passed to the script
function steward:ext() {
	local ARGS=("$@");
	local url=;         args:arg url '^https?://' || return;
	local shell="bash"; args:arg -o shell;

	local file; file="$(printf '%s' "$url" | sed -E 's#[^A-Za-z0-9._-]+#-#g')";
	cat <<-SH >> /tmp/steward/140--ext-installer.sh
		curl -1fsSLR -z '/var/cache/steward/$file' -o '/var/cache/steward/$file' '$url';
		cat '/var/cache/steward/$file' | '$shell' ${ARGS[@]};
	SH
}

# @name npm
# @type keyword
# @desc Install npm packages (global by default, local with --dir)
#
# @usage npm <name[@version]>
# @usage npm --dir <path> [name[@version]]
#
# @opt  [--dir <path>] -- Project directory. Without name: `npm install`. With name: `npm install <name>`.
# @arg  [name[@version]] -- Package name, optionally with @version suffix. Without --dir: global install.
function steward:npm() {
	local ARGS=("$@");
	local dir=; args:opt dir "";
	local name=; args:arg -o name;

	[[ -z "$dir" && -z "$name" ]] && return 1;

	[[ ! -f /tmp/steward/npm-packages ]] && ! command -v npm >/dev/null 2>&1 && {
		if [[ -n "${NODEVS:-}" ]]; then
			steward:key nodesource https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key;
			steward:src nodesource "https://deb.nodesource.com/node_${NODEVS}.x" nodistro main;
			steward:apt nodejs;
		else
			steward:apt nodejs;
		fi
	}

	local key="${dir:-!global}";
	grep -q "^${key}	" /tmp/steward/npm-packages 2>/dev/null \
		&& sed -i "s|^${key}	.*|& ${name}|" /tmp/steward/npm-packages \
		|| printf '%s\t%s\n' "$key" "$name" >> /tmp/steward/npm-packages;
}

# @name composer
# @type keyword
# @desc Install composer packages (global by default, local with --dir)
#
# @usage composer <name[:version]>
# @usage composer --dir <path> [name[:version]]
#
# @opt  [--dir <path>] -- Project directory. Without name: `composer install`. With name: `composer require <name>`.
# @arg  [name[:version]] -- Package name, optionally with :version constraint. Without --dir: global require.
function steward:composer() {
	local ARGS=("$@");
	local dir=; args:opt dir "";
	local name=; args:arg -o name;

	[[ -z "$dir" && -z "$name" ]] && return 1;

	[[ ! -f /tmp/steward/composer-packages ]] && ! command -v php >/dev/null 2>&1 && {
		[[ "${ID:-}" == "debian" ]] \
			&& steward:key php https://packages.sury.org/php/apt.gpg \
			&& steward:src php "https://packages.sury.org/php/" "$VERSION_CODENAME" main;
		[[ "${ID:-}" == "ubuntu" ]] \
			&& steward:key php "https://keyserver.ubuntu.com/pks/lookup?op=get&search=0xB8DC7E53946656EFBCE4C1DD71DAEAAB4AD4CAB6" \
			&& steward:src php "https://ppa.launchpadcontent.net/ondrej/php/ubuntu" "$VERSION_CODENAME" main;
		steward:apt "php${PHPVS:-}-cli";
		steward:ext https://getcomposer.org/installer php -- --2 --install-dir=/usr/local/bin --filename=composer;
	}

	local key="${dir:-!global}";
	grep -q "^${key}	" /tmp/steward/composer-packages 2>/dev/null \
		&& sed -i "s|^${key}	.*|& ${name}|" /tmp/steward/composer-packages \
		|| printf '%s\t%s\n' "$key" "$name" >> /tmp/steward/composer-packages;
}

# @name helm
# @type keyword
# @desc Install a Helm chart
#
# @usage helm [namespace/]<release> <chart[@version]> [repo] [--timeout <seconds>] [<<<yaml]
#
# @arg  [namespace/]<release> -- Release name, optionally prefixed with namespace/
# @arg  <chart[@version]> -- Chart reference (e.g. bitnami/nginx@1.2.3)
# @arg  [repo] -- Repository URL to add (chart prefix used as repo name)
# @opt  [--timeout <seconds>] -- Helm timeout in seconds (default: 60)
function steward:helm() {
	local ARGS=("$@");
	local release=;  args:arg release || return;
	local chart=;    args:arg chart || return;
	local repo=;     args:arg -o repo '^https?://';
	local timeout=;  args:opt timeout "";

	[[ ! -f /tmp/steward/180--helm-install.sh ]] && ! command -v helm >/dev/null 2>&1 && {
		steward:key helm https://packages.buildkite.com/helm-linux/helm-debian/gpgkey;
		steward:src helm https://packages.buildkite.com/helm-linux/helm-debian/any/ any main;
		steward:apt helm;
	}

	# Extract namespace from release (namespace/release → --namespace namespace)
	local namespace=;
	[[ "$release" == */* ]] && namespace="${release%%/*}" && release="${release##*/}";

	# Extract version from chart (chart@version → --version version)
	local version=;
	[[ "$chart" == *@* ]] && version="${chart##*@}" && chart="${chart%%@*}";

	if [[ -n "$repo" ]]; then
		cat <<-SH >> /tmp/steward/180--helm-install.sh
			helm repo add '${chart%%/*}' '$repo';
			helm repo update;
		SH
	fi

	# Accept YAML values from stdin if provided
	local values=;
	[[ ! -t 0 ]] && values="$(cat)" 2>/dev/null;

	cat <<-SH >> /tmp/steward/180--helm-install.sh
		helm upgrade --install '$release' '$chart' \
			--atomic --wait --timeout '${timeout:-60}s' \
			${namespace:+--namespace '$namespace' --create-namespace} \
			${version:+--version '$version'} \
			${values:+--values - <<< '$values'};
	SH
}

# @name pip
# @type keyword
# @desc Install pip packages (global by default, local venv with --dir)
#
# @usage pip <name[==version]>
# @usage pip --dir <path> [name[==version]]
#
# @opt  [--dir <path>] -- Project directory. Without name: venv + `pip install -r requirements.txt`. With name: venv + `pip install <name>`.
# @arg  [name[==version]] -- Package name, optionally with ==version constraint. Without --dir: global install.
function steward:pip() {
	local ARGS=("$@");
	local dir=; args:opt dir "";
	local name=; args:arg -o name;

	[[ -z "$dir" && -z "$name" ]] && return 1;

	[[ ! -f /tmp/steward/pip-packages ]] && ! command -v pip3 >/dev/null 2>&1 && {
		steward:apt --temp python3-pip python3-venv;
	}

	local key="${dir:-!global}";
	grep -q "^${key}	" /tmp/steward/pip-packages 2>/dev/null \
		&& sed -i "s|^${key}	.*|& ${name}|" /tmp/steward/pip-packages \
		|| printf '%s\t%s\n' "$key" "$name" >> /tmp/steward/pip-packages;
}

# @name go
# @type keyword
# @desc Install Go packages (global by default, local with --dir)
#
# @usage go <name[@version]>
# @usage go --dir <path> [name[@version]]
#
# @opt  [--dir <path>] -- Project directory. Without name: `go mod download`. With name: `go get <name>`.
# @arg  [name[@version]] -- Module path, optionally with @version (default: @latest). Without --dir: global install.
function steward:go() {
	local ARGS=("$@");
	local dir=; args:opt dir "";
	local name=; args:arg -o name;

	[[ -z "$dir" && -z "$name" ]] && return 1;

	[[ ! -f /tmp/steward/go-packages ]] && ! command -v go >/dev/null 2>&1 && {
		steward:apt golang;
	}

	[[ -n "$name" && "$name" != *@* ]] && name="${name}@latest";

	local key="${dir:-!global}";
	grep -q "^${key}	" /tmp/steward/go-packages 2>/dev/null \
		&& sed -i "s|^${key}	.*|& ${name}|" /tmp/steward/go-packages \
		|| printf '%s\t%s\n' "$key" "$name" >> /tmp/steward/go-packages;
}

# @name eager
# @type keyword
# @desc Run shell commands before the built-in pipeline (eager scripts: 0-99)
#       Use --internal to inject within the built-in pipeline (100-199)
#
# @usage eager [:ord] [name] <<<"command"
# @usage eager --internal [:ord] [name] <<<"command"
# @usage eager [:ord] [name] <<SH ... SH
#
# @arg  [:ord]		Order of script execution (00-99). Default 00.
# @flag [--internal]	Shift base from 000 to 100 (injection into the built-in pipeline).
# @arg  [name]		Label.
function steward:eager() {
	local ARGS=("$@");
	local internal=; args:flag internal "";
	local ord="00";  args:arg -o ord '^:([0-9]{2})$';
	local name=;     args:arg -o name;

	local base=0; [[ "$internal" == "true" ]] && base=100;
	# bashism: 10# forces base-10: without it, leading zeros (e.g. 08, 09) would be parsed as invalid octal
	ord=$(printf '%03d' $((base + 10#$ord)));

	cat <<-SH >> "/tmp/steward/$ord-eager-$name.sh";
		echo;
		echo "--- BEGIN $name";
		$(cat)
		echo "=== END $name";
	SH
}

# @name defer
# @type keyword
# @desc Defer shell commands to run after all packages are installed (deferred scripts: 0-99)
#
# @usage defer [:ord] [name] <<<"command"
# @usage defer [:ord] [name] <<SH ... SH
#
# @arg [:ord]	Order of script execution (00-99). Default 00.
# @arg [name]	Label
function steward:defer() {
	local ARGS=("$@");
	local ord="00"; args:arg -o ord '^:([0-9]{2})$';
	local name=;    args:arg -o name;

	# bashism: 10# forces base-10: without it, leading zeros (e.g. 08, 09) would be parsed as invalid octal
	ord=$(printf '%03d' $((200 + 10#$ord)));

	cat <<-SH >> "/tmp/steward/$ord-deferred-$name.sh";
		echo;
		echo "--- BEGIN $name";
		$(cat)
		echo "=== END $name";
	SH
}

# @name on-amd64
# @type keyword
# @desc Run a command only on amd64 architecture
#
# @usage on-amd64 <keyword> <args...>
#
# @arg <keyword> -- The steward keyword to run (e.g. deb, apt)
# @arg [...args] -- Arguments for the keyword
function steward:on-amd64() {
	if [[ "$ARCH" == "amd64" ]]; then
		# Direct "$@" won't work, it breaks quoting, can trigger globbing.
		# bashism printf %q shell-escapes each arg; eval re-parses them.
		eval "$(printf '%q ' "$@")";
	fi
}

# @name on-arm64
# @type keyword
# @desc Run a command only on arm64 architecture
#
# @usage on-arm64 <keyword> <args...>
#
# @arg <keyword> -- The steward keyword to run (e.g. deb, apt)
# @arg [...args] -- Arguments for the keyword
function steward:on-arm64() {
	if [[ "$ARCH" == "arm64" ]]; then
		eval "$(printf '%q ' "$@")";
	fi
}

# @name in-dev
# @type keyword
# @desc Run a command only in dev environment (APP_ENV=dev, APP_DEBUG=1, or DEBUG set)
#
# @usage in-dev <keyword> <args...>
#
# @arg <keyword> -- The steward keyword to run (e.g. deb, apt)
# @arg [...args] -- Arguments for the keyword
function steward:in-dev() {
	if [[ "${APP_ENV:-}" == "dev" || "${APP_DEBUG:-}" == "1" || -n "${DEBUG:-}" ]]; then
		eval "$(printf '%q ' "$@")";
	fi
}

# @type keyword
# @name apply
# @desc Execute all queued operations in order (auto-invoked unless steward is importd/sourced)
#
# @flag [-d|--dry-run] -- Dry run -- read the Stewardfiles, check the syntax & parameters, display what commands would be executed.
function steward:apply() {
	local ARGS=("$@");
	local dry_run=; args:flag dry-run d;
	local source="source";

	# Run the rest in privileged mode
	[[ "$EUID" -ne 0 && "$dry_run" != "true" ]] && exec sudo "$0" "$@";
	# @todo ^^ $0 only applies if not sourced

	# Dry-run prints the queue scripts instead of executing them (swaps `source` for `cat`)
	[[ "$dry_run" == "true" ]] && source="cat";

	# Create apt-install + cleanup scripts if any packages were queued
	local pkg_files=(/tmp/steward/apt-packages*)
	if [[ ${#pkg_files[@]} -gt 0 ]]; then
		cat <<-'SH' > "/tmp/steward/130--apt-install.sh"
			command -v apt >/dev/null 2>&1 || (echo "apt is not installed" && exit 1);

			apt update -qq;

			cat /tmp/steward/apt-packages-tmp >> /tmp/steward/apt-packages 2>/dev/null;
			sort -u /tmp/steward/apt-packages 2>/dev/null | xargs -r apt install -qqy --no-install-recommends;
			sort -u /tmp/steward/apt-packages-try 2>/dev/null | xargs -r apt install -qqy --no-install-recommends || true;
		SH
	fi

	# Docker containers need APT cleanup (after all installers)
	if [[ -f /.dockerenv ]]; then cat <<-'SH' > "/tmp/steward/199--apt-cleanup.sh"
		[[ -f /tmp/steward/apt-packages-tmp ]] &&
			sort -u /tmp/steward/apt-packages-tmp |
			while read -r e; do [[ "$e" == *.deb ]] && dpkg-deb --field "$e" Package 2>/dev/null || echo "$e"; done |
			xargs -r apt remove -qqy;
		apt autoremove -y --purge;
		findmnt /var/cache/apt/archives || apt clean;             # Only clean if it wasn't mounted (as a cache)
		findmnt /var/lib/apt/lists || rm -fR /var/lib/apt/lists;  # Only clean if it wasn't mounted (as a cache)
		findmnt /var/cache/steward || rm -fr /var/cache/steward;  # Only clean if it wasn't mounted (as a cache)
	SH
	fi

	# Generate install scripts from package manager manifests (dir\tpackages per line)
	[[ -f /tmp/steward/npm-packages ]] && while IFS=$'\t' read -r dir pkgs; do
		[[ "$dir" == "!global" ]] && echo "npm install --global $pkgs;" >> "/tmp/steward/160--npm-install.sh" && continue;
		[[ -z "$pkgs" ]]          && echo "(cd '$dir' && npm install);" >> "/tmp/steward/160--npm-install.sh" && continue;
		echo "(cd '$dir' && npm install $pkgs);" >> "/tmp/steward/160--npm-install.sh";
	done < /tmp/steward/npm-packages

	[[ -f /tmp/steward/composer-packages ]] && while IFS=$'\t' read -r dir pkgs; do
		[[ "$dir" == "!global" ]] && echo "composer global require $pkgs;" >> "/tmp/steward/170--composer-install.sh" && continue;
		[[ -z "$pkgs" ]]          && echo "(cd '$dir' && composer install);" >> "/tmp/steward/170--composer-install.sh" && continue;
		echo "(cd '$dir' && composer require $pkgs);" >> "/tmp/steward/170--composer-install.sh";
	done < /tmp/steward/composer-packages

	[[ -f /tmp/steward/pip-packages ]] && while IFS=$'\t' read -r dir pkgs; do
		[[ "$dir" == "!global" ]] && echo "pip3 install $pkgs;" >> "/tmp/steward/190--pip-install.sh" && continue;
		[[ -z "$pkgs" ]]          && echo "(cd '$dir' && python3 -m venv .venv && .venv/bin/pip install -r requirements.txt);" >> "/tmp/steward/190--pip-install.sh" && continue;
		echo "(cd '$dir' && python3 -m venv .venv && .venv/bin/pip install $pkgs);" >> "/tmp/steward/190--pip-install.sh";
	done < /tmp/steward/pip-packages

	[[ -f /tmp/steward/go-packages ]] && while IFS=$'\t' read -r dir pkgs; do
		[[ "$dir" == "!global" ]] && echo "for pkg in $pkgs; do go install \"\$pkg\"; done;" >> "/tmp/steward/195--go-install.sh" && continue;
		[[ -z "$pkgs" ]]          && echo "(cd '$dir' && go mod download);" >> "/tmp/steward/195--go-install.sh" && continue;
		echo "(cd '$dir' && go get $pkgs);" >> "/tmp/steward/195--go-install.sh";
	done < /tmp/steward/go-packages

	# shellcheck source=/dev/null # We do not depend on the symbols inside this script
	for script in /tmp/steward/[0-9][0-9][0-9]-*.sh; do
		$source "$script" || { echo "ERROR: Script failed: $script" >&2; exit 1; }
	done
}

function steward:help() {
	source .deps/@help;
}

source .deps/@github/curatorium/bash-args@latest/bash-args.sh;
source .deps/@github/curatorium/bash-import@latest/namespace.sh;
source .deps/@github/curatorium/bash-import@latest/strict.sh;
source .deps/@github/curatorium/bash-import@latest/trace.sh;

steward:main "$@";
